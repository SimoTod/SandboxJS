class Prop{constructor(e,t,r=!1,s=!1){this.context=e,this.prop=t,this.isConst=r,this.isGlobal=s}}class Lisp{constructor(e){this.op=e.op,this.a=e.a,this.b=e.b}}class If{constructor(e,t){this.t=e,this.f=t}}class KeyVal{constructor(e,t){this.key=e,this.val=t}}class Scope{constructor(e,t={},r=!1,s){this.const={},this.var={},this.globals={},this.parent=e,this.let=e?t:{},this.globals=e?{}:t,this.globalProp=s,this.functionScope=r||!e}get(e,t=!1){if(!this.parent||!t||this.functionScope){if(e in this.const)return new Prop(this.const,e,!0,e in this.globals);if(e in this.var)return new Prop(this.var,e,!1,e in this.globals);if(e in this.let)return new Prop(this.let,e,!1,e in this.globals);if(!this.parent&&e in this.globals)return new Prop(this.globalProp.context.global,e,!1,!0);if(!this.parent)return new Prop(void 0,e)}return this.parent.get(e,t)}set(e,t){let r=this.get(e);if(void 0===r.context)throw new Error(`Variable '${e}' was not declared.`);if(r.isConst)throw Error(`Cannot assign to const variable '${e}'`);if(r.isGlobal)throw Error(`Cannot override global variable '${e}'`);return r.context[r]=t,r}declare(e,t=null,r,s=!1){if("var"===t&&!this.functionScope&&this.parent)this.parent.declare(e,t,r);else{if(e in this.var&&e in this.let&&e in this.const&&e in this.globals)throw Error(`Variable '${e}' already declared`);s&&(this.globals[e]=r),this[t][e]=r}}}class SandboxGlobal{constructor(e){if(e===globalThis)return globalThis;for(let t in e)this[t]=e[t]}}function sandboxFunction(e){return function SandboxFunction(...t){let r=t.pop(),s=Sandbox.parse(r);return function(...r){const n={this:void 0};for(let e of t)n[e]=r.shift();n.this=null!=this?this:globalThis;const i=new Scope(e.globalScope,n),o=e.sandbox.executeTree(s,[i]);if(e.options.audit){for(let t in o.auditReport.globalsAccess){let r=o.auditReport.globalsAccess[t];e.auditReport.globalsAccess[t]=e.auditReport.globalsAccess[t]||new Set,r.forEach(r=>{e.auditReport.globalsAccess[t].add(r)})}for(let t in o.auditReport.prototypeAccess){let r=o.auditReport.prototypeAccess[t];e.auditReport.prototypeAccess[t]=e.auditReport.prototypeAccess[t]||new Set,r.forEach(r=>{e.auditReport.prototypeAccess[t].add(r)})}}return o.result}}}function sandboxedEval(e){return function(t){return e(t)()}}let expectTypes={op:{types:{op:/^(\/|\*\*(?!\=)|\*(?!\=)|\%(?!\=))/},next:["value","prop","exp","modifier","incrementerBefore"]},splitter:{types:{split:/^(&&|&|\|\||\||<=|>=|<|>|!==|!=|===|==|#io#|\+(?!\+)|\-(?!\-))(?!\=)/},next:["value","prop","exp","modifier","incrementerBefore"]},if:{types:{if:/^\?/,else:/^:/},next:["expEnd"]},assignment:{types:{assignModify:/^(\-=|\+=|\/=|\*\*=|\*=|%=|\^=|\&=|\|=)/,assign:/^(=)/},next:["value","prop","exp","modifier","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|\-\-)/},next:["prop"]},incrementerAfter:{types:{incrementerAfter:/^(\+\+|\-\-)/},next:["splitter","op","expEnd"]},expEdge:{types:{arrayProp:/^[\[]/,call:/^[\(]/},next:["splitter","op","expEdge","if","dot","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^\-(?!\-)/,positive:/^\+(?!\+)/,typeof:/^#to#/},next:["exp","modifier","value","prop","incrementerBefore"]},exp:{types:{createObject:/^\{/,createArray:/^\[/,group:/^\(/},next:["splitter","op","expEdge","if","dot","expEnd"]},dot:{types:{dot:/^\./},next:["splitter","incrementerAfter","assignment","op","expEdge","if","dot","expEnd"]},prop:{types:{prop:/^[a-zA-Z\$_][a-zA-Z\d\$_]*/},next:["splitter","incrementerAfter","assignment","op","expEdge","if","dot","expEnd"]},value:{types:{number:/^\-?\d+(\.\d+)?/,string:/^"(\d+)"/,literal:/^`(\d+)`/,boolean:/^(true|false)(?![\w$_])/,null:/^null(?![\w$_])/,und:/^undefined(?![\w$_])/,NaN:/^NaN(?![\w$_])/,Infinity:/^Infinity(?![\w$_])/},next:["splitter","op","if","dot","expEnd"]},initialize:{types:{initialize:/^#(var|let|const)#[a-zA-Z\$_][a-zA-Z\d\$_]*/},next:["value","prop","exp","modifier","incrementerBefore"]},expEnd:{types:{},next:[]},expStart:{types:{return:/^#return#/},next:["value","prop","exp","modifier","incrementerBefore","expEnd"]}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"};const restOfExp=(e,t,r)=>{let s=/^[\+\-~#!]/,n=!0;t=t||[expectTypes.op.types.op,expectTypes.splitter.types.split,expectTypes.if.types.if,expectTypes.if.types.else];let i,o=!1,p=!1;for(i=0;i<e.length&&!p;i++){let l=e[i];if('"'===r||"'"===r||"`"===r){if("`"!==r||"$"!==l||"{"!==e[i+1]||o){if(l===r&&!o)return e.substring(0,i)}else{i+=restOfExp(e.substring(i+2),[/^}/]).length+2}o="\\"===l}else if(closings[l]){i+=restOfExp(e.substring(i+1),[new RegExp("^\\"+closings[r])],l).length+1,n=!1}else if(r){if(l===closings[r])return e.substring(0,i)}else{let r=e.substring(i);if(t.forEach(e=>{p=p||e.test(r)}),n&&(s.test(r)?p=!1:n=!1),p)break}}return e.substring(0,i)};function assignCheck(e){if(void 0===e.context)throw new Error("Cannot assign value to undefined.");if(e.isConst)throw new Error(`Cannot set value to const variable '${e.prop}'`);if(e.isGlobal)throw Error(`Cannot override property of global variable '${e.prop}'`);if(!e.context.hasOwnProperty(e.prop)&&e.prop in e.context)throw Error(`Cannot override prototype property '${e.prop}'`)}restOfExp.next=["splitter","op","expEnd"];let ops2={prop:(e,t,r,s,n)=>{if(void 0===e){let e=n.get(t);if(void 0===e.context)throw new Error(`${t} is not defined`);if(e.context===s.globalProp.context.global){if(s.options.audit&&s.auditReport.globalsAccess.add(t),s.globalProp.context.global[t]===Function)return s.Function;if(s.globalProp.context.global[t]===eval)return s.eval;const e=s.globalProp.context.global[t];if(setTimeout===e||e===setInterval)return}return e.context&&e.context[t]===globalThis?s.globalProp:e}let i=!1;if(null===e)throw new Error("Cannot get propety of null");if("number"==typeof e&&(e=new Number(e)),"string"==typeof e&&(e=new String(e)),"boolean"==typeof e&&(e=new Boolean(e)),i=e.hasOwnProperty(t)||parseInt(t,10)+""==t+"",!i&&s.options.audit&&(i=!0,"string"==typeof t&&(s.auditReport.prototypeAccess[e.constructor.name]||(s.auditReport.prototypeAccess[e.constructor.name]=new Set),s.auditReport.prototypeAccess[e.constructor.name].add(t))),!i&&s.prototypeWhitelist.has(e.constructor)){let r=s.prototypeWhitelist.get(e.constructor)||[];i=!r.length||r.includes(t)}else i||s.prototypeWhitelist.forEach((r,s)=>{!i&&e instanceof s&&(i=i||e[t]===s.prototype[t],i=i&&(!r||!r.length||r.includes(t)))});if(i){if(e[t]===Function)return s.Function;if(e[t]===globalThis)return s.globalProp;let n=r.isGlobal||e.constructor===Function&&"prototype"===t;return new Prop(e,t,!1,n)}throw Error(`Method or property access prevented: ${e.constructor.name}.${t}`)},call:(e,t,r,s,n)=>{if(s.options.forbidMethodCalls)throw new Error("Method calls are not allowed");if("function"!=typeof e)throw new Error(`${r.prop} is not a function`);return"function"==typeof r?r(...t.map(e=>exec(e,n,s))):r.context[r.prop](...t.map(e=>exec(e,n,s)))},createObject:(e,t)=>{let r={};for(let e of t)r[e.key]=e.val;return r},keyVal:(e,t)=>new KeyVal(e,t),createArray:(e,t,r,s,n)=>t.map(e=>exec(e,n,s)),group:(e,t)=>t,string:(e,t,r,s)=>s.strings[t],literal:(e,t,r,s,n)=>s.literals[t].a.replace(/(\$\$)*(\$)?\${(\d+)}/g,(e,r,i,o)=>{if(i)return e;let p=exec(s.literals[t].b[parseInt(o,10)],n,s);return p=p instanceof Prop?p.context[p.prop]:p,(r||"")+`${p}`.replace(/\$/g,"$$")}).replace(/\$\$/g,"$"),"!":(e,t)=>!t,"~":(e,t)=>~t,"++$":(e,t,r)=>++r.context[r.prop],"$++":(e,t,r)=>r.context[r.prop]++,"--$":(e,t,r)=>--r.context[r.prop],"$--":(e,t,r)=>r.context[r.prop]--,"=":(e,t,r,s,n,i)=>(assignCheck(r),r.context[r.prop]=t,new Prop(r.context,r.prop,!1,r.isGlobal)),"+=":(e,t,r)=>(assignCheck(r),r.context[r.prop]+=t),"-=":(e,t,r)=>(assignCheck(r),r.context[r.prop]-=t),"/=":(e,t,r)=>(assignCheck(r),r.context[r.prop]/=t),"*=":(e,t,r)=>(assignCheck(r),r.context[r.prop]*=t),"**=":(e,t,r)=>(assignCheck(r),r.context[r.prop]**=t),"%=":(e,t,r)=>(assignCheck(r),r.context[r.prop]%=t),"^=":(e,t,r)=>(assignCheck(r),r.context[r.prop]^=t),"&=":(e,t,r)=>(assignCheck(r),r.context[r.prop]&=t),"|=":(e,t,r)=>(assignCheck(r),r.context[r.prop]|=t),"?":(e,t)=>{if(!(t instanceof If))throw new Error("Invalid inline if");return e?t.t:t.f},">":(e,t)=>e>t,"<":(e,t)=>e<t,">=":(e,t)=>e>=t,"<=":(e,t)=>e<=t,"==":(e,t)=>e==t,"===":(e,t)=>e===t,"!=":(e,t)=>e!=t,"!==":(e,t)=>e!==t,"&&":(e,t)=>e&&t,"||":(e,t)=>e||t,"&":(e,t)=>e&t,"|":(e,t)=>e|t,":":(e,t)=>new If(e,t),"+":(e,t)=>e+t,"-":(e,t)=>e-t,"$+":(e,t)=>+t,"$-":(e,t)=>-t,"/":(e,t)=>e/t,"*":(e,t)=>e*t,"%":(e,t)=>e%t,"#to#":(e,t)=>typeof t,"#io#":(e,t)=>e instanceof t,return:(e,t)=>t,var:(e,t,r,s,n,i)=>(n.declare(e,"var",exec(t,n,s)),new Prop(n.var,e,!1,i&&i.isGlobal)),let:(e,t,r,s,n,i)=>(n.declare(e,"let",exec(t,n,s),i&&i.isGlobal),new Prop(n.let,e,!1,i&&i.isGlobal)),const:(e,t,r,s,n,i)=>(n.declare(e,"const",exec(t,n,s)),new Prop(n.const,e,!1,i&&i.isGlobal))},ops=new Map;for(let e in ops2)ops.set(e,ops2[e]);let lispTypes={},setLispType=(e,t)=>{e.forEach(e=>{lispTypes[e]=t})};function lispify(e,t,r){if(t=t||["initialize","expStart","value","prop","exp","modifier","incrementerBefore","expEnd"],!e.length&&!t.includes("expEnd"))throw new Error("Unexpected end of expression");let s,n={lispTree:r};if(t.forEach(r=>{if("expEnd"!==r)for(let i in expectTypes[r].types){if(s)break;"expEnd"!==i&&((s=expectTypes[r].types[i].exec(e))&&(lispTypes[i](i,e,s,r,n),t=expectTypes[r].next))}}),!s&&e.length)throw Error("Unexpected token: "+e);return n.lispTree}function exec(e,t,r){if(e instanceof Prop)return e.context[e.prop];if(Array.isArray(e))return e.map(e=>exec(e,t,r));if(!(e instanceof Lisp))return e;let s=exec(e.a,t,r),n=s instanceof Prop?s.context?s.context[s.prop]:void 0:s,i=exec(e.b,t,r),o=i instanceof Prop?i.context?i.context[i.prop]:void 0:i;if(ops.has(e.op)){return ops.get(e.op)(n,o,s,r,t,i)}throw new Error("Unknown operator: "+e.op)}setLispType(["createArray","createObject","group","arrayProp","call"],(e,t,r,s,n)=>{let i,o="",p={createArray:"]",createObject:"}",group:")",arrayProp:"]",call:")"},l=[],a=!1,c=1;for(;c<t.length&&!a;)o=restOfExp(t.substring(c),[new RegExp("^\\"+p[e]),/^,/]),c+=o.length,o&&l.push(o),","!==t[c]?a=!0:c++;switch(e){case"group":case"arrayProp":i=lispify(l.pop());break;case"call":case"createArray":i=l.map(e=>lispify(e));break;case"createObject":i=l.map(e=>{let t=restOfExp(e,[/^:/]),r=lispify(t);r instanceof Lisp&&"prop"===r.op&&(r=r.b);let s=lispify(e.substring(t.length+1));return new Lisp({op:"keyVal",a:r,b:s})})}e="arrayProp"===e?"prop":e,n.lispTree=lispify(t.substring(c+1),expectTypes[s].next,new Lisp({op:e,a:n.lispTree,b:i}))}),setLispType(["op"],(e,t,r,s,n)=>{let i=restOfExp(t.substring(r[0].length));n.lispTree=new Lisp({op:r[0],a:n.lispTree,b:lispify(i)}),n.lispTree=lispify(t.substring(i.length+r[0].length),restOfExp.next,n.lispTree)}),setLispType(["inverse","not","negative","positive","typeof"],(e,t,r,s,n)=>{let i=restOfExp(t.substring(r[0].length));n.lispTree=new Lisp({op:["positive","negative"].includes(e)?"$"+r[0]:r[0],a:n.lispTree,b:lispify(i,expectTypes[s].next)}),n.lispTree=lispify(t.substring(i.length+r[0].length),restOfExp.next,n.lispTree)}),setLispType(["incrementerBefore"],(e,t,r,s,n)=>{let i=restOfExp(t.substring(2));n.lispTree=lispify(t.substring(i.length+2),restOfExp.next,new Lisp({op:r[0]+"$",a:lispify(i,expectTypes[s].next)}))}),setLispType(["incrementerAfter"],(e,t,r,s,n)=>{n.lispTree=lispify(t.substring(r[0].length),expectTypes[s].next,new Lisp({op:"$"+r[0],a:n.lispTree}))}),setLispType(["assign","assignModify"],(e,t,r,s,n)=>{n.lispTree=new Lisp({op:r[0],a:n.lispTree,b:lispify(t.substring(r[0].length),expectTypes[s].next)})}),setLispType(["split"],(e,t,r,s,n)=>{let i=restOfExp(t.substring(r[0].length),[expectTypes.splitter.types.split,expectTypes.if.types.if,expectTypes.if.types.else]);n.lispTree=new Lisp({op:r[0],a:n.lispTree,b:lispify(i,expectTypes[s].next)}),n.lispTree=lispify(t.substring(i.length+r[0].length),restOfExp.next,n.lispTree)}),setLispType(["if"],(e,t,r,s,n)=>{let i=!1,o="",p=1;for(;!i&&o.length<t.length;)o+=restOfExp(t.substring(o.length+1),[expectTypes.if.types.if,expectTypes.if.types.else]),"?"===t[o.length+1]?p++:p--,p?o+=t[o.length+1]:i=!0;n.lispTree=new Lisp({op:"?",a:n.lispTree,b:new Lisp({op:":",a:lispify(o),b:lispify(t.substring(r[0].length+o.length+1))})})}),setLispType(["dot","prop"],(e,t,r,s,n)=>{let i=r[0],o=r[0].length;if("."===r[0]){let e=t.substring(r[0].length).match(expectTypes.prop.types.prop);if(!e.length)throw Error("Hanging  dot:"+t);i=e[0],o=i.length+r[0].length}n.lispTree=lispify(t.substring(o),expectTypes[s].next,new Lisp({op:"prop",a:n.lispTree,b:i}))}),setLispType(["number","boolean","null"],(e,t,r,s,n)=>{n.lispTree=lispify(t.substring(r[0].length),expectTypes[s].next,JSON.parse(r[0]))}),setLispType(["und"],(e,t,r,s,n)=>{n.lispTree=lispify(t.substring(r[0].length),expectTypes[s].next,void 0)}),setLispType(["NaN"],(e,t,r,s,n)=>{n.lispTree=lispify(t.substring(r[0].length),expectTypes[s].next,NaN)}),setLispType(["Infinity"],(e,t,r,s,n)=>{n.lispTree=lispify(t.substring(r[0].length),expectTypes[s].next,1/0)}),setLispType(["string","literal"],(e,t,r,s,n)=>{n.lispTree=lispify(t.substring(r[0].length),expectTypes[s].next,new Lisp({op:e,b:parseInt(JSON.parse(r[1]),10)}))}),setLispType(["return"],(e,t,r,s,n)=>{n.lispTree=new Lisp({op:"return",b:lispify(t.substring(r[0].length),expectTypes[s].next)})}),setLispType(["initialize"],(e,t,r,s,n)=>{const i=r[0].split(/#/g);t.length===r[0].length?n.lispTree=lispify(t.substring(r[0].length),expectTypes[s].next,new Lisp({op:i[1],a:i[2]})):n.lispTree=new Lisp({op:i[1],a:i[2],b:lispify(t.substring(r[0].length+1),expectTypes[s].next)})});let optimizeTypes={},setOptimizeType=(e,t)=>{e.forEach(e=>{optimizeTypes[e]=t})};function optimize(e,t,r){if(!(e instanceof Lisp)){if(Array.isArray(e)){for(let s=0;s<e.length;s++)e[s]=optimize(e[s],t,r);return e}return e}return e.a=optimize(e.a,t,r),e.b=optimize(e.b,t,r),e.a instanceof Lisp||e.b instanceof Lisp||!optimizeTypes[e.op]?e:optimizeTypes[e.op](e,t,r)}setOptimizeType([">","<",">=","<=","==","===","!=","!==","&&","||","&","|","+","-","/","*","**","%","$+","$-","!","~","group"],e=>ops.get(e.op)(e.a,e.b)),setOptimizeType(["string"],(e,t)=>t[e.b]),setOptimizeType(["literal"],(e,t,r)=>r[e.b].b.length?e:r[e.b].a),setOptimizeType(["createArray"],e=>e.b.find(e=>e instanceof Lisp)?e:ops.get(e.op)(e.a,e.b)),setOptimizeType(["prop"],e=>"number"==typeof e.b&&e.b%1==0?e.a[e.b]:e);export default class Sandbox{constructor(e={},t=new Map,r={audit:!1}){let s=new Prop({global:new SandboxGlobal(e)},"global",!1,!0);this.context={sandbox:this,globals:e,prototypeWhitelist:t,options:r,globalScope:new Scope(null,e,!0,s),globalProp:s,Function:()=>()=>{},eval:()=>{},auditReport:{prototypeAccess:{},globalsAccess:new Set}},this.context.Function=sandboxFunction(this.context),this.context.eval=sandboxedEval(this.context.Function)}static get SAFE_GLOBALS(){return{Function:Function,eval:eval,console:console,isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math}}static get SAFE_PROTOTYPES(){let e=[SandboxGlobal,Function,Boolean,Object,Number,String,Date,RegExp,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise],t=new Map;return e.forEach(e=>{t.set(e,[])}),t}static audit(e,t=[]){let r=new Map;return new Sandbox(globalThis,r,{audit:!0}).executeTree(Sandbox.parse(e),t)}static parse(e,t=[],r=[]){let s,n=e,i="",o=!1,p=[],l=0;for(let e=0;e<n.length;e++){let a=n[e];if(o)if("$"===a&&"`"===s)a="$$";else if("u"===a){let t,r=/^[a-fA-F\d]{2,4}/.exec(n.substring(e+1));t=r?Array.from(r):Array.from(/^{[a-fA-F\d]+}/.exec(n.substring(e+1))||[""]),a=JSON.parse(`"\\u${t[0]}"`),n=n.substring(0,e-1)+a+n.substring(e+(1+t[0].length)),e-=1}else"`"!=a&&(a=JSON.parse(`"\\${a}"`));else"$"===a&&"`"===s&&"{"!==n[e+1]&&(a="$$");if("`"===s&&"$"===a&&"{"===n[e+1]){let s=restOfExp(n.substring(e+2),[/^}/]);p.push(this.parse(s,t,r).tree[0]),l+=s.length+3,i+=`\${${p.length-1}}`,e+=s.length+2}else if(s||"'"!==a&&'"'!==a&&"`"!==a||o)if(s!==a||o)s&&(o||"\\"!==a)&&(l+=o?1+a.length:a.length,i+=a);else{let o;"`"===s?(r.push({op:"literal",a:i,b:p}),n=n.substring(0,e-l-1)+`\`${r.length-1}\``+n.substring(e+1),o=(r.length-1).toString().length):(t.push(i),n=n.substring(0,e-i.length-1)+`"${t.length-1}"`+n.substring(e+1),o=(t.length-1).toString().length),s=null,e-=i.length-o,i=""}else p=[],l=0,s=a;o=s&&!o&&"\\"===a}return{tree:n.replace(/ instanceof /g," #io# ").replace(/(?:(^|\s))(return)(?=[\s;])/g,"#return#").replace(/(?:(^|\s))(var|let|const)(?=[\s])/g,e=>`#${e}#`).replace(/(?:(^|\s))typeof /g,"#to#").replace(/\s/g,"").split(";").filter(e=>e.length).map(e=>lispify(e)).map(e=>optimize(e,t,r)),strings:t,literals:r}}executeTree(e,t=[]){const r=e.tree,s=Object.assign(Object.assign({},this.context),{strings:e.strings,literals:e.literals});let n,i=this.context.globalScope;for(;n=t.shift();)"object"==typeof n&&(i=n instanceof Scope?n:new Scope(i,n));let o=Object.assign({},s);s.options.audit&&(o.auditReport={globalsAccess:new Set,prototypeAccess:{}});let p=!1,l=-1,a=r.map(e=>p?null:(l++,e instanceof Lisp&&"return"===e.op&&(p=!0),exec(e,i,o)))[l];return a=a instanceof Prop?a.context[a.prop]:a,{auditReport:o.auditReport,result:a}}compile(e){const t=Sandbox.parse(e);return(...e)=>this.executeTree(t,e).result}}