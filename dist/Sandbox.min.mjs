class Prop{constructor(e,t,r=!1,n=!1){this.context=e,this.prop=t,this.isConst=r,this.isGlobal=n}}class Lisp{constructor(e){this.op=e.op,this.a=e.a,this.b=e.b}}class If{constructor(e,t){this.true=e,this.false=t}}class KeyVal{constructor(e,t){this.key=e,this.value=t}}class Scope{constructor(e,t=!1,r={}){this.const={},this.var={},this.parent=e,this.let=e?r:{},this.globals=e?{}:r,this.functionScope=t||!e}get(e,t=!1){if(!this.parent||!t||this.functionScope){if(!this.parent&&e in this.globals.context.global)return new Prop(this.globals.context.global,e,!1,!0);if(e in this.const)return new Prop(this.const,e,!0);if(e in this.var)return new Prop(this.var,e);if(e in this.let)return new Prop(this.let,e);if(!this.parent)return new Prop(void 0,e)}return this.parent.get(e,t)}set(e,t){let r=this.get(e);if(void 0===r.context)throw new Error(`Variable '${e}' was not declared.`);if(r.isConst)throw Error(`Cannot assign to const variable '${e}'`);if(r.isGlobal)throw Error(`Cannot override global variable '${e}'`);return r.context[r]=t,r}declare(e,t=null,r){if("var"===t&&!this.functionScope&&this.parent)this.parent.declare(e,t,r);else{if(e in this.var&&e in this.let&&e in this.const&&e in this.globals)throw Error(`Variable '${e}' already declared`);this[t][e]=r}}}class SandboxGlobal{constructor(e){if(e===globalThis)return globalThis;for(let t in e)this[t]=e[t]}}function sandboxFunction(e){return function SandboxFunction(...t){let r=t.pop(),n=e.sandbox.parse(r);return function(...r){const s={this:void 0};for(let e of t)s[e]=r.shift();s.this=null!=this?this:globalThis;const i=new Scope(e.globalScope,!1,s),p=n(i);if(e.options.audit){e.auditReport.globalsAccess=new Set([...e.auditReport.globalsAccess,...p.audit.globalsAccess]);for(let t in p.audit.prototypeAccess){let r=p.audit.prototypeAccess[t];e.auditReport.prototypeAccess[t]&&(r=new Set([...e.auditReport.prototypeAccess[t],...r])),e.auditReport.prototypeAccess[t]=r}return p.res}return p}}}function sandboxedEval(e){const t=sandboxFunction(e);return function(e){return t(e)()}}let expectTypes={op:{types:{op:/^(\/|\*\*|\*|%)/},next:["value","prop","exp","modifier","incrementerBefore"]},splitter:{types:{split:/^(&&|&|\|\||\||<=|>=|<|>|!==|!=|===|==|#io#|\+|\-)/},next:["value","prop","exp","modifier","incrementerBefore"]},if:{types:{if:/^\?/,else:/^:/},next:["expEnd"]},assignment:{types:{assignModify:/^(\-=|\+=|\/=|\*=|%=|\^=|&=|\|=)/,assign:/^(=)/},next:["value","prop","exp","modifier","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|\-\-)/},next:["prop"]},incrementerAfter:{types:{incrementerAfter:/^(\+\+|\-\-)/},next:["splitter","op","expEnd"]},expEdge:{types:{arrayProp:/^[\[]/,call:/^[\(]/},next:["splitter","op","expEdge","if","dot","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^\-/,positive:/^\+/,typeof:/^#to#/},next:["exp","modifier","value","prop","incrementerBefore"]},exp:{types:{createObject:/^\{/,createArray:/^\[/,group:/^\(/},next:["splitter","op","expEdge","if","dot","expEnd"]},dot:{types:{dot:/^\./},next:["splitter","incrementerAfter","assignment","op","expEdge","if","dot","expEnd"]},prop:{types:{prop:/^[a-zA-Z\$_][a-zA-Z\d\$_]*/},next:["splitter","incrementerAfter","assignment","op","expEdge","if","dot","expEnd"]},value:{types:{number:/^\-?\d+(\.\d+)?/,string:/^"(\d+)"/,literal:/^`(\d+)`/,boolean:/^(true|false)(?![\w$_])/,null:/^null(?![\w$_])/,und:/^undefined(?![\w$_])/,NaN:/^NaN(?![\w$_])/,Infinity:/^Infinity(?![\w$_])/,event:/^event(?![\w$_])/},next:["splitter","op","if","dot","expEnd"]},initialize:{types:{initialize:/^#(var|let|const)#[a-zA-Z\$_][a-zA-Z\d\$_]*/},next:["assignment","expEnd"]},expEnd:{types:{},next:[]},expStart:{types:{return:/^#return#/},next:["value","prop","exp","modifier","incrementerBefore","expEnd"]}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"};const restOfExp=(e,t,r)=>{let n=/^[\+\-~#!]/,s=!0;t=t||[expectTypes.op.types.op,expectTypes.splitter.types.split,expectTypes.if.types.if,expectTypes.if.types.else];let i,p=!1,o=!1;for(i=0;i<e.length&&!o;i++){let l=e[i];if('"'===r||"'"===r||"`"===r){if("`"!==r||"$"!==l||"{"!==e[i+1]||p){if(l===r&&!p)return e.substring(0,i)}else{i+=restOfExp(e.substring(i+2),[/^}/]).length+2}p="\\"===l}else if(closings[l]){i+=restOfExp(e.substring(i+1),[new RegExp("^\\"+closings[r])],l).length+1,s=!1}else if(r){if(l===closings[r])return e.substring(0,i)}else{let r=e.substring(i);if(t.forEach(e=>{o=o||e.test(r)}),s&&(n.test(r)?o=!1:s=!1),o)break}}return e.substring(0,i)};function assignCheck(e){if(void 0===e.context)throw new Error("Cannot assign value to undefined.");if(e.isConst)throw new Error(`Cannot set value to const variable '${e.prop}'`);if(e.isGlobal)throw Error(`Cannot override property of global variable '${e.prop}'`);if(!e.context.hasOwnProperty(e.prop)&&e.prop in e.context)throw Error("Cannot override prototype property:")}restOfExp.next=["splitter","op","expEnd"];let ops2={prop:(e,t,r,n,s)=>{if(void 0===e){let e=s.get(t);if(void 0===e.context)throw new Error(`${t} is not defined`);if(e.context===n.globalProp.context.global){if(n.options.audit&&n.auditReport.globalsAccess.add(t),n.globalProp.context.global[t]===Function)return n.Function;if(n.globalProp.context.global[t]===eval)return n.eval;const e=n.globalProp.context.global[t];if(setTimeout===e||e===setInterval)return}return e.context&&e.context[t]===globalThis?n.globalProp:e}let i=!1;if(null===e)throw new Error("Cannot get propety of null");if("number"==typeof e&&(e=new Number(e)),"string"==typeof e&&(e=new String(e)),"boolean"==typeof e&&(e=new Boolean(e)),i=e.hasOwnProperty(t)||parseInt(t,10)+""==t+"",!i&&n.options.audit&&(i=!0,"string"==typeof t&&(n.auditReport.prototypeAccess[e.constructor.name]||(n.auditReport.prototypeAccess[e.constructor.name]=new Set),n.auditReport.prototypeAccess[e.constructor.name].add(t))),!i&&n.prototypeWhitelist.has(e.constructor)){let r=n.prototypeWhitelist.get(e.constructor)||[];i=!r.length||r.includes(t)}else i||n.prototypeWhitelist.forEach((r,n)=>{!i&&e instanceof n&&(i=i||e[t]===n.prototype[t],i=i&&(!r||!r.length||r.includes(t)))});if(i)return e[t]===Function?n.Function:e[t]===globalThis?n.globalProp:new Prop(e,t,!1,r.isGlobal);throw Error(`Method or property access prevented: ${e.constructor.name}.${t}`)},call:(e,t,r,n,s)=>{if("function"!=typeof e)throw new Error(`${r.prop} is not a function`);return"function"==typeof r?r(...t.map(e=>exec(e,s,n))):r.context[r.prop](...t.map(e=>exec(e,s,n)))},createObject:(e,t)=>{let r={};for(let e of t)r[e.key]=e.value;return r},keyVal:(e,t)=>new KeyVal(e,t),createArray:(e,t,r,n,s)=>t.map(e=>exec(e,s,n)),group:(e,t)=>t,string:(e,t,r,n)=>n.strings[t],literal:(e,t,r,n,s)=>n.literals[t].a.replace(/(\$\$)*(\$)?\${(\d+)}/g,(e,r,i,p)=>i?e:(r||"")+n.literals[t].b[parseInt(p,10)](s).toString().replace(/\$/g,"$$")).replace(/\$\$/g,"$"),event:(e,t,r,n,s)=>(s.get("event").context===n.globals&&n.options.audit&&n.auditReport.globalsAccess.add("event"),t()),"!":(e,t)=>!t,"~":(e,t)=>~t,"++$":(e,t,r)=>++r.context[r.prop],"$++":(e,t,r)=>r.context[r.prop]++,"--$":(e,t,r)=>--r.context[r.prop],"$--":(e,t,r)=>r.context[r.prop]--,"=":(e,t,r)=>(assignCheck(r),r.context[r.prop]=t),"+=":(e,t,r)=>(assignCheck(r),r.context[r.prop]+=t),"-=":(e,t,r)=>(assignCheck(r),r.context[r.prop]-=t),"/=":(e,t,r)=>(assignCheck(r),r.context[r.prop]/=t),"*=":(e,t,r)=>(assignCheck(r),r.context[r.prop]*=t),"%=":(e,t,r)=>(assignCheck(r),r.context[r.prop]%=t),"^=":(e,t,r)=>(assignCheck(r),r.context[r.prop]^=t),"&=":(e,t,r)=>(assignCheck(r),r.context[r.prop]&=t),"|=":(e,t,r)=>(assignCheck(r),r.context[r.prop]|=t),"?":(e,t)=>{if(!(t instanceof If))throw new Error("Invalid inline if");return e?t.true:t.false},">":(e,t)=>e>t,"<":(e,t)=>e<t,">=":(e,t)=>e>=t,"<=":(e,t)=>e<=t,"==":(e,t)=>e==t,"===":(e,t)=>e===t,"!=":(e,t)=>e!=t,"!==":(e,t)=>e!==t,"&&":(e,t)=>e&&t,"||":(e,t)=>e||t,"&":(e,t)=>e&t,"|":(e,t)=>e|t,":":(e,t)=>new If(e,t),"+":(e,t)=>e+t,"-":(e,t)=>e-t,"$+":(e,t)=>+t,"$-":(e,t)=>-t,"/":(e,t)=>e/t,"*":(e,t)=>e*t,"%":(e,t)=>e%t,"#to#":(e,t)=>typeof t,"#io#":(e,t)=>e instanceof t,return:(e,t)=>t,var:(e,t,r,n,s)=>(s.declare(e,"var",exec(t,s,n)),new Prop(s.var,e)),let:(e,t,r,n,s)=>(s.declare(e,"let",exec(t,s,n)),new Prop(s.let,e)),const:(e,t,r,n,s)=>(s.declare(e,"const",exec(t,s,n)),new Prop(s.const,e))},ops=new Map;for(let e in ops2)ops.set(e,ops2[e]);let lispTypes={},setLispType=(e,t)=>{e.forEach(e=>{lispTypes[e]=t})};function lispify(e,t,r){if(t=t||["initialize","expStart","value","prop","exp","modifier","incrementerBefore","expEnd"],!e.length&&!t.includes("expEnd"))throw new Error("Unexpected end of expression");let n,s={lispTree:r};if(t.forEach(r=>{if("expEnd"!==r)for(let i in expectTypes[r].types){if(n)break;"expEnd"!==i&&((n=expectTypes[r].types[i].exec(e))&&(lispTypes[i](i,e,n,r,s),t=expectTypes[r].next))}}),!n&&e.length)throw Error("Unexpected token: "+e);return s.lispTree}function exec(e,t,r){if(e instanceof Prop)return e.context[e.prop];if(Array.isArray(e))return e.map(e=>exec(e,t,r));if(!(e instanceof Lisp))return e;let n=exec(e.a,t,r),s=n instanceof Prop?n.context?n.context[n.prop]:void 0:n,i=exec(e.b,t,r),p=i instanceof Prop?i.context?i.context[i.prop]:void 0:i;if(ops.has(e.op)){return ops.get(e.op)(s,p,n,r,t)}throw new Error("Unknown operator: "+e.op)}setLispType(["createArray","createObject","group","arrayProp","call"],(e,t,r,n,s)=>{let i="",p={createArray:"]",createObject:"}",group:")",arrayProp:"]",call:")"},o=[],l=!1,a=1;for(;a<t.length&&!l;)i=restOfExp(t.substring(a),[new RegExp("^\\"+p[e]),/^,/]),a+=i.length,i&&o.push(i),","!==t[a]?l=!0:a++;switch(e){case"group":case"arrayProp":o=lispify(o.pop());break;case"call":case"createArray":o=o.map(e=>lispify(e));break;case"createObject":o=o.map(e=>{let t=restOfExp(e,[/^:/]),r=lispify(t);r instanceof Lisp&&"prop"===r.op&&(r=r.b);let n=lispify(e.substring(t.length+1));return new Lisp({op:"keyVal",a:r,b:n})})}e="arrayProp"===e?"prop":e,s.lispTree=lispify(t.substring(a+1),expectTypes[n].next,new Lisp({op:e,a:s.lispTree,b:o}))}),setLispType(["op"],(e,t,r,n,s)=>{let i=restOfExp(t.substring(r[0].length));s.lispTree=new Lisp({op:r[0],a:s.lispTree,b:lispify(i)}),s.lispTree=lispify(t.substring(i.length+r[0].length),restOfExp.next,s.lispTree)}),setLispType(["inverse","not","negative","positive","typeof"],(e,t,r,n,s)=>{let i=restOfExp(t.substring(r[0].length));s.lispTree=new Lisp({op:["positive","negative"].includes(e)?"$"+r[0]:r[0],a:s.lispTree,b:lispify(i,expectTypes[n].next)}),s.lispTree=lispify(t.substring(i.length+r[0].length),restOfExp.next,s.lispTree)}),setLispType(["incrementerBefore"],(e,t,r,n,s)=>{let i=restOfExp(t.substring(2));s.lispTree.b=new Lisp({op:r[0]+"$",a:lispify(i,expectTypes[n].next)}),s.lispTree=lispify(t.substring(i.length+2),restOfExp.next,s.lispTree)}),setLispType(["incrementerAfter"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:"$"+r[0],a:s.lispTree}))}),setLispType(["assign","assignModify"],(e,t,r,n,s)=>{s.lispTree=new Lisp({op:r[0],a:s.lispTree,b:lispify(t.substring(r[0].length),expectTypes[n].next)})}),setLispType(["split"],(e,t,r,n,s)=>{let i=restOfExp(t.substring(r[0].length),[expectTypes.splitter.types.split,expectTypes.if.types.if,expectTypes.if.types.else]);s.lispTree=new Lisp({op:r[0],a:s.lispTree,b:lispify(i,expectTypes[n].next)}),s.lispTree=lispify(t.substring(i.length+r[0].length),restOfExp.next,s.lispTree)}),setLispType(["if"],(e,t,r,n,s)=>{let i=!1,p="",o=1;for(;!i&&p.length<t.length;)p+=restOfExp(t.substring(p.length+1),[expectTypes.if.types.if,expectTypes.if.types.else]),"?"===t[p.length+1]?o++:o--,o?p+=t[p.length+1]:i=!0;s.lispTree=new Lisp({op:"?",a:s.lispTree,b:new Lisp({op:":",a:lispify(p),b:lispify(t.substring(r[0].length+p.length+1))})})}),setLispType(["dot","prop"],(e,t,r,n,s)=>{let i=r[0],p=r[0].length;if("."===r[0]){let e=t.substring(r[0].length).match(expectTypes.prop.types.prop);if(!e.length)throw Error("Hanging  dot:"+t);i=e[0],p=i.length+r[0].length}s.lispTree=lispify(t.substring(p),expectTypes[n].next,new Lisp({op:"prop",a:s.lispTree,b:i}))}),setLispType(["event"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:e,b:()=>globalThis.event}))}),setLispType(["number","boolean","null"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,JSON.parse(r[0]))}),setLispType(["und"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,void 0)}),setLispType(["NaN"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,NaN)}),setLispType(["Infinity"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,1/0)}),setLispType(["string","literal"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:e,b:parseInt(JSON.parse(r[1]),10)}))}),setLispType(["return"],(e,t,r,n,s)=>{s.lispTree=new Lisp({op:"return",b:lispify(t.substring(r[0].length),expectTypes[n].next)})}),setLispType(["initialize"],(e,t,r,n,s)=>{const i=r[0].split(/#/g);t.length>r[0].length?s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:i[1],a:i[2]})):s.lispTree=new Lisp({op:i[1],a:i[2],b:lispify(t.substring(r[0].length),expectTypes[n].next)})});let optimizeTypes={},setOptimizeType=(e,t)=>{e.forEach(e=>{optimizeTypes[e]=t})};function optimize(e,t,r){if(!(e instanceof Lisp)){if(Array.isArray(e)){for(let n=0;n<e.length;n++)e[n]=optimize(e[n],t,r);return e}return e}return e.a=optimize(e.a,t,r),e.b=optimize(e.b,t,r),e.a instanceof Lisp||e.b instanceof Lisp||!optimizeTypes[e.op]?e:optimizeTypes[e.op](e,t,r)}setOptimizeType([">","<",">=","<=","==","===","!=","!==","&&","||","&","|","+","-","/","*","**","%","$+","$-","!","~","group"],e=>ops.get(e.op)(e.a,e.b)),setOptimizeType(["string"],(e,t)=>t[e.b]),setOptimizeType(["literal"],(e,t,r)=>r[e.b].b.length?e:r[e.b].a),setOptimizeType(["createArray"],e=>e.b.find(e=>e instanceof Lisp)?e:ops.get(e.op)(e.a,e.b)),setOptimizeType(["prop"],e=>parseInt(e.b,10)+""==e.b+""||"string"!=typeof e.b?e.a[e.b]:e);export default class Sandbox{constructor(e={},t=new Map,r={audit:!1}){let n=new Prop({global:new SandboxGlobal(e)},"global",!1,!0);this.context={sandbox:this,globals:e,prototypeWhitelist:t,options:r,globalScope:new Scope(null,!0,n),globalProp:n},this.context.Function=sandboxFunction(this.context),this.context.eval=sandboxedEval(this.context)}static get SAFE_GLOBALS(){return{Function:Function,eval:eval,console:console,isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math}}static get SAFE_PROTOTYPES(){let e=[SandboxGlobal,Function,Boolean,Object,Number,String,Date,RegExp,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise],t=new Map;return e.forEach(e=>{t.set(e,[])}),t}static audit(e){let t=new Map;return new Sandbox(globalThis,t,{audit:!0}).parse(e)()}parse(e){let t,r=e,n="",s=!1;const i=[];let p=[],o=Object.assign({strings:i,literals:p},this.context),l=[],a=0;for(let e=0;e<r.length;e++){let o=r[e];if(s)if("$"===o&&"`"===t)o="$$";else if("u"===o){let t,n=/^[a-fA-F\d]{2,4}/.exec(r.substring(e+1));t=n?Array.from(n):Array.from(/^{[a-fA-F\d]+}/.exec(r.substring(e+1))||[""]),o=JSON.parse(`"\\u${t[0]}"`),r=r.substring(0,e-1)+o+r.substring(e+(1+t[0].length)),e-=1}else"`"!=o&&(o=JSON.parse(`"\\${o}"`));else"$"===o&&"`"===t&&"{"!==r[e+1]&&(o="$$");if("`"===t&&"$"===o&&"{"===r[e+1]){let t=restOfExp(r.substring(e+2),[/^}/]);l.push(this.parse(t)),a+=t.length+3,n+=`\${${l.length-1}}`,e+=t.length+2}else if(t||"'"!==o&&'"'!==o&&"`"!==o||s)if(t!==o||s)t&&(s||"\\"!==o)&&(a+=s?1+o.length:o.length,n+=o);else{let s;"`"===t?(p.push({op:"literal",a:n,b:l}),r=r.substring(0,e-a-1)+`\`${p.length-1}\``+r.substring(e+1),s=(p.length-1).toString().length):(i.push(n),r=r.substring(0,e-n.length-1)+`"${i.length-1}"`+r.substring(e+1),s=(i.length-1).toString().length),t=null,e-=n.length-s,n=""}else l=[],a=0,t=o;s=t&&!s&&"\\"===o}let c=r.replace(/ instanceof /g," #io# ").replace(/(?:(^|\s))(return)(?=[\s;])/g,"#return#").replace(/(?:(^|\s))(var|let|const)(?=[\s])/g,e=>`#${e}#`).replace(/(?:(^|\s))typeof /g,"#to#").replace(/\s/g,"").split(";").filter(e=>e.length).map(e=>lispify(e)).map(e=>optimize(e,i,p));return(...e)=>{let t,r=this.context.globalScope;for(;t=e.shift();)"object"==typeof t&&(r=t instanceof Scope?t:new Scope(r,!1,t));let n=Object.assign({},o);o.options.audit&&(n.auditReport={globalsAccess:new Set,prototypeAccess:{}});let s=!1,i=-1,p=c.map(e=>s?null:(i++,e instanceof Lisp&&"return"===e.op&&(s=!0),exec(e,r,n)))[i];return p=p instanceof Prop?p.context[p.prop]:p,n.options.audit?{audit:n.auditReport,res:p}:p}}}