class Prop{constructor(e,t,r=!1,n=!1){this.context=e,this.prop=t,this.isConst=r,this.isGlobal=n}}class Lisp{constructor(e){this.op=e.op,this.a=e.a,this.b=e.b}}class If{constructor(e,t){this.t=e,this.f=t}}class KeyVal{constructor(e,t){this.key=e,this.val=t}}class Scope{constructor(e,t={},r=!1,n){this.const={},this.var={},this.globals={},this.parent=e,this.let=e?t:{},this.globals=e?{}:t,this.globalProp=n,this.functionScope=r||!e}get(e,t=!1){if(!this.parent||!t||this.functionScope){if(e in this.const)return new Prop(this.const,e,!0,e in this.globals);if(e in this.var)return new Prop(this.var,e,!1,e in this.globals);if(e in this.let)return new Prop(this.let,e,!1,e in this.globals);if(!this.parent&&e in this.globals)return new Prop(this.globalProp.context.global,e,!1,!0);if(!this.parent)return new Prop(void 0,e)}return this.parent.get(e,t)}set(e,t){let r=this.get(e);if(void 0===r.context)throw new Error(`Variable '${e}' was not declared.`);if(r.isConst)throw Error(`Cannot assign to const variable '${e}'`);if(r.isGlobal)throw Error(`Cannot override global variable '${e}'`);return r.context[r]=t,r}declare(e,t=null,r,n=!1){if("var"===t&&!this.functionScope&&this.parent)this.parent.declare(e,t,r);else{if(e in this.var&&e in this.let&&e in this.const&&e in this.globals)throw Error(`Variable '${e}' already declared`);n&&(this.globals[e]=r),this[t][e]=r}}}class SandboxGlobal{constructor(e){if(e===globalThis)return globalThis;for(let t in e)this[t]=e[t]}}function sandboxFunction(e){return function SandboxFunction(...t){let r=t.pop(),n=e.sandbox.compile(r);return function(...r){const s={this:void 0};for(let e of t)s[e]=r.shift();s.this=null!=this?this:globalThis;const i=new Scope(e.globalScope,s),o=n(i);if(e.options.audit){e.auditReport.globalsAccess=new Set([...e.auditReport.globalsAccess,...o.audit.globalsAccess]);for(let t in o.audit.prototypeAccess){let r=o.audit.prototypeAccess[t];e.auditReport.prototypeAccess[t]&&(r=new Set([...e.auditReport.prototypeAccess[t],...r])),e.auditReport.prototypeAccess[t]=r}return o.res}return o}}}function sandboxedEval(e){return function(t){return e(t)()}}let expectTypes={op:{types:{op:/^(\/|\*\*|\*|%)/},next:["value","prop","exp","modifier","incrementerBefore"]},splitter:{types:{split:/^(&&|&|\|\||\||<=|>=|<|>|!==|!=|===|==|#io#|\+|\-)/},next:["value","prop","exp","modifier","incrementerBefore"]},if:{types:{if:/^\?/,else:/^:/},next:["expEnd"]},assignment:{types:{assignModify:/^(\-=|\+=|\/=|\*=|%=|\^=|&=|\|=)/,assign:/^(=)/},next:["value","prop","exp","modifier","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|\-\-)/},next:["prop"]},incrementerAfter:{types:{incrementerAfter:/^(\+\+|\-\-)/},next:["splitter","op","expEnd"]},expEdge:{types:{arrayProp:/^[\[]/,call:/^[\(]/},next:["splitter","op","expEdge","if","dot","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^\-/,positive:/^\+/,typeof:/^#to#/},next:["exp","modifier","value","prop","incrementerBefore"]},exp:{types:{createObject:/^\{/,createArray:/^\[/,group:/^\(/},next:["splitter","op","expEdge","if","dot","expEnd"]},dot:{types:{dot:/^\./},next:["splitter","incrementerAfter","assignment","op","expEdge","if","dot","expEnd"]},prop:{types:{prop:/^[a-zA-Z\$_][a-zA-Z\d\$_]*/},next:["splitter","incrementerAfter","assignment","op","expEdge","if","dot","expEnd"]},value:{types:{number:/^\-?\d+(\.\d+)?/,string:/^"(\d+)"/,literal:/^`(\d+)`/,boolean:/^(true|false)(?![\w$_])/,null:/^null(?![\w$_])/,und:/^undefined(?![\w$_])/,NaN:/^NaN(?![\w$_])/,Infinity:/^Infinity(?![\w$_])/},next:["splitter","op","if","dot","expEnd"]},initialize:{types:{initialize:/^#(var|let|const)#[a-zA-Z\$_][a-zA-Z\d\$_]*/},next:["value","prop","exp","modifier","incrementerBefore"]},expEnd:{types:{},next:[]},expStart:{types:{return:/^#return#/},next:["value","prop","exp","modifier","incrementerBefore","expEnd"]}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"};const restOfExp=(e,t,r)=>{let n=/^[\+\-~#!]/,s=!0;t=t||[expectTypes.op.types.op,expectTypes.splitter.types.split,expectTypes.if.types.if,expectTypes.if.types.else];let i,o=!1,p=!1;for(i=0;i<e.length&&!p;i++){let l=e[i];if('"'===r||"'"===r||"`"===r){if("`"!==r||"$"!==l||"{"!==e[i+1]||o){if(l===r&&!o)return e.substring(0,i)}else{i+=restOfExp(e.substring(i+2),[/^}/]).length+2}o="\\"===l}else if(closings[l]){i+=restOfExp(e.substring(i+1),[new RegExp("^\\"+closings[r])],l).length+1,s=!1}else if(r){if(l===closings[r])return e.substring(0,i)}else{let r=e.substring(i);if(t.forEach(e=>{p=p||e.test(r)}),s&&(n.test(r)?p=!1:s=!1),p)break}}return e.substring(0,i)};function assignCheck(e){if(void 0===e.context)throw new Error("Cannot assign value to undefined.");if(e.isConst)throw new Error(`Cannot set value to const variable '${e.prop}'`);if(e.isGlobal)throw Error(`Cannot override property of global variable '${e.prop}'`);if(!e.context.hasOwnProperty(e.prop)&&e.prop in e.context)throw Error(`Cannot override prototype property '${e.prop}'`)}restOfExp.next=["splitter","op","expEnd"];let ops2={prop:(e,t,r,n,s)=>{if(void 0===e){let e=s.get(t);if(void 0===e.context)throw new Error(`${t} is not defined`);if(e.context===n.globalProp.context.global){if(n.options.audit&&n.auditReport.globalsAccess.add(t),n.globalProp.context.global[t]===Function)return n.Function;if(n.globalProp.context.global[t]===eval)return n.eval;const e=n.globalProp.context.global[t];if(setTimeout===e||e===setInterval)return}return e.context&&e.context[t]===globalThis?n.globalProp:e}let i=!1;if(null===e)throw new Error("Cannot get propety of null");if("number"==typeof e&&(e=new Number(e)),"string"==typeof e&&(e=new String(e)),"boolean"==typeof e&&(e=new Boolean(e)),i=e.hasOwnProperty(t)||parseInt(t,10)+""==t+"",!i&&n.options.audit&&(i=!0,"string"==typeof t&&(n.auditReport.prototypeAccess[e.constructor.name]||(n.auditReport.prototypeAccess[e.constructor.name]=new Set),n.auditReport.prototypeAccess[e.constructor.name].add(t))),!i&&n.prototypeWhitelist.has(e.constructor)){let r=n.prototypeWhitelist.get(e.constructor)||[];i=!r.length||r.includes(t)}else i||n.prototypeWhitelist.forEach((r,n)=>{!i&&e instanceof n&&(i=i||e[t]===n.prototype[t],i=i&&(!r||!r.length||r.includes(t)))});if(i){if(e[t]===Function)return n.Function;if(e[t]===globalThis)return n.globalProp;let s=r.isGlobal||e.constructor===Function&&"prototype"===t;return new Prop(e,t,!1,s)}throw Error(`Method or property access prevented: ${e.constructor.name}.${t}`)},call:(e,t,r,n,s)=>{if(n.options.forbidMethodCalls)throw new Error("Method calls are not allowed");if("function"!=typeof e)throw new Error(`${r.prop} is not a function`);return"function"==typeof r?r(...t.map(e=>exec(e,s,n))):r.context[r.prop](...t.map(e=>exec(e,s,n)))},createObject:(e,t)=>{let r={};for(let e of t)r[e.key]=e.val;return r},keyVal:(e,t)=>new KeyVal(e,t),createArray:(e,t,r,n,s)=>t.map(e=>exec(e,s,n)),group:(e,t)=>t,string:(e,t,r,n)=>n.strings[t],literal:(e,t,r,n,s)=>n.literals[t].a.replace(/(\$\$)*(\$)?\${(\d+)}/g,(e,r,i,o)=>{if(i)return e;let p=exec(n.literals[t].b[parseInt(o,10)],s,n);return p=p instanceof Prop?p.context[p.prop]:p,(r||"")+`${p}`.replace(/\$/g,"$$")}).replace(/\$\$/g,"$"),"!":(e,t)=>!t,"~":(e,t)=>~t,"++$":(e,t,r)=>++r.context[r.prop],"$++":(e,t,r)=>r.context[r.prop]++,"--$":(e,t,r)=>--r.context[r.prop],"$--":(e,t,r)=>r.context[r.prop]--,"=":(e,t,r,n,s,i)=>(assignCheck(r),r.context[r.prop]=t,new Prop(r.context,r.prop,!1,r.isGlobal)),"+=":(e,t,r)=>(assignCheck(r),r.context[r.prop]+=t),"-=":(e,t,r)=>(assignCheck(r),r.context[r.prop]-=t),"/=":(e,t,r)=>(assignCheck(r),r.context[r.prop]/=t),"*=":(e,t,r)=>(assignCheck(r),r.context[r.prop]*=t),"%=":(e,t,r)=>(assignCheck(r),r.context[r.prop]%=t),"^=":(e,t,r)=>(assignCheck(r),r.context[r.prop]^=t),"&=":(e,t,r)=>(assignCheck(r),r.context[r.prop]&=t),"|=":(e,t,r)=>(assignCheck(r),r.context[r.prop]|=t),"?":(e,t)=>{if(!(t instanceof If))throw new Error("Invalid inline if");return e?t.t:t.f},">":(e,t)=>e>t,"<":(e,t)=>e<t,">=":(e,t)=>e>=t,"<=":(e,t)=>e<=t,"==":(e,t)=>e==t,"===":(e,t)=>e===t,"!=":(e,t)=>e!=t,"!==":(e,t)=>e!==t,"&&":(e,t)=>e&&t,"||":(e,t)=>e||t,"&":(e,t)=>e&t,"|":(e,t)=>e|t,":":(e,t)=>new If(e,t),"+":(e,t)=>e+t,"-":(e,t)=>e-t,"$+":(e,t)=>+t,"$-":(e,t)=>-t,"/":(e,t)=>e/t,"*":(e,t)=>e*t,"%":(e,t)=>e%t,"#to#":(e,t)=>typeof t,"#io#":(e,t)=>e instanceof t,return:(e,t)=>t,var:(e,t,r,n,s,i)=>(s.declare(e,"var",exec(t,s,n)),new Prop(s.var,e,!1,i&&i.isGlobal)),let:(e,t,r,n,s,i)=>(s.declare(e,"let",exec(t,s,n),i&&i.isGlobal),new Prop(s.let,e,!1,i&&i.isGlobal)),const:(e,t,r,n,s,i)=>(s.declare(e,"const",exec(t,s,n)),new Prop(s.const,e,!1,i&&i.isGlobal))},ops=new Map;for(let e in ops2)ops.set(e,ops2[e]);let lispTypes={},setLispType=(e,t)=>{e.forEach(e=>{lispTypes[e]=t})};function lispify(e,t,r){if(t=t||["initialize","expStart","value","prop","exp","modifier","incrementerBefore","expEnd"],!e.length&&!t.includes("expEnd"))throw new Error("Unexpected end of expression");let n,s={lispTree:r};if(t.forEach(r=>{if("expEnd"!==r)for(let i in expectTypes[r].types){if(n)break;"expEnd"!==i&&((n=expectTypes[r].types[i].exec(e))&&(lispTypes[i](i,e,n,r,s),t=expectTypes[r].next))}}),!n&&e.length)throw Error("Unexpected token: "+e);return s.lispTree}function exec(e,t,r){if(e instanceof Prop)return e.context[e.prop];if(Array.isArray(e))return e.map(e=>exec(e,t,r));if(!(e instanceof Lisp))return e;let n=exec(e.a,t,r),s=n instanceof Prop?n.context?n.context[n.prop]:void 0:n,i=exec(e.b,t,r),o=i instanceof Prop?i.context?i.context[i.prop]:void 0:i;if(ops.has(e.op)){return ops.get(e.op)(s,o,n,r,t,i)}throw new Error("Unknown operator: "+e.op)}setLispType(["createArray","createObject","group","arrayProp","call"],(e,t,r,n,s)=>{let i,o="",p={createArray:"]",createObject:"}",group:")",arrayProp:"]",call:")"},l=[],a=!1,c=1;for(;c<t.length&&!a;)o=restOfExp(t.substring(c),[new RegExp("^\\"+p[e]),/^,/]),c+=o.length,o&&l.push(o),","!==t[c]?a=!0:c++;switch(e){case"group":case"arrayProp":i=lispify(l.pop());break;case"call":case"createArray":i=l.map(e=>lispify(e));break;case"createObject":i=l.map(e=>{let t=restOfExp(e,[/^:/]),r=lispify(t);r instanceof Lisp&&"prop"===r.op&&(r=r.b);let n=lispify(e.substring(t.length+1));return new Lisp({op:"keyVal",a:r,b:n})})}e="arrayProp"===e?"prop":e,s.lispTree=lispify(t.substring(c+1),expectTypes[n].next,new Lisp({op:e,a:s.lispTree,b:i}))}),setLispType(["op"],(e,t,r,n,s)=>{let i=restOfExp(t.substring(r[0].length));s.lispTree=new Lisp({op:r[0],a:s.lispTree,b:lispify(i)}),s.lispTree=lispify(t.substring(i.length+r[0].length),restOfExp.next,s.lispTree)}),setLispType(["inverse","not","negative","positive","typeof"],(e,t,r,n,s)=>{let i=restOfExp(t.substring(r[0].length));s.lispTree=new Lisp({op:["positive","negative"].includes(e)?"$"+r[0]:r[0],a:s.lispTree,b:lispify(i,expectTypes[n].next)}),s.lispTree=lispify(t.substring(i.length+r[0].length),restOfExp.next,s.lispTree)}),setLispType(["incrementerBefore"],(e,t,r,n,s)=>{let i=restOfExp(t.substring(2));if(!(s.lispTree instanceof Lisp))throw new Error("Invalid operation: "+t);s.lispTree.b=new Lisp({op:r[0]+"$",a:lispify(i,expectTypes[n].next)}),s.lispTree=lispify(t.substring(i.length+2),restOfExp.next,s.lispTree)}),setLispType(["incrementerAfter"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:"$"+r[0],a:s.lispTree}))}),setLispType(["assign","assignModify"],(e,t,r,n,s)=>{s.lispTree=new Lisp({op:r[0],a:s.lispTree,b:lispify(t.substring(r[0].length),expectTypes[n].next)})}),setLispType(["split"],(e,t,r,n,s)=>{let i=restOfExp(t.substring(r[0].length),[expectTypes.splitter.types.split,expectTypes.if.types.if,expectTypes.if.types.else]);s.lispTree=new Lisp({op:r[0],a:s.lispTree,b:lispify(i,expectTypes[n].next)}),s.lispTree=lispify(t.substring(i.length+r[0].length),restOfExp.next,s.lispTree)}),setLispType(["if"],(e,t,r,n,s)=>{let i=!1,o="",p=1;for(;!i&&o.length<t.length;)o+=restOfExp(t.substring(o.length+1),[expectTypes.if.types.if,expectTypes.if.types.else]),"?"===t[o.length+1]?p++:p--,p?o+=t[o.length+1]:i=!0;s.lispTree=new Lisp({op:"?",a:s.lispTree,b:new Lisp({op:":",a:lispify(o),b:lispify(t.substring(r[0].length+o.length+1))})})}),setLispType(["dot","prop"],(e,t,r,n,s)=>{let i=r[0],o=r[0].length;if("."===r[0]){let e=t.substring(r[0].length).match(expectTypes.prop.types.prop);if(!e.length)throw Error("Hanging  dot:"+t);i=e[0],o=i.length+r[0].length}s.lispTree=lispify(t.substring(o),expectTypes[n].next,new Lisp({op:"prop",a:s.lispTree,b:i}))}),setLispType(["number","boolean","null"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,JSON.parse(r[0]))}),setLispType(["und"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,void 0)}),setLispType(["NaN"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,NaN)}),setLispType(["Infinity"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,1/0)}),setLispType(["string","literal"],(e,t,r,n,s)=>{s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:e,b:parseInt(JSON.parse(r[1]),10)}))}),setLispType(["return"],(e,t,r,n,s)=>{s.lispTree=new Lisp({op:"return",b:lispify(t.substring(r[0].length),expectTypes[n].next)})}),setLispType(["initialize"],(e,t,r,n,s)=>{const i=r[0].split(/#/g);t.length===r[0].length?s.lispTree=lispify(t.substring(r[0].length),expectTypes[n].next,new Lisp({op:i[1],a:i[2]})):s.lispTree=new Lisp({op:i[1],a:i[2],b:lispify(t.substring(r[0].length+1),expectTypes[n].next)})});let optimizeTypes={},setOptimizeType=(e,t)=>{e.forEach(e=>{optimizeTypes[e]=t})};function optimize(e,t,r){if(!(e instanceof Lisp)){if(Array.isArray(e)){for(let n=0;n<e.length;n++)e[n]=optimize(e[n],t,r);return e}return e}return e.a=optimize(e.a,t,r),e.b=optimize(e.b,t,r),e.a instanceof Lisp||e.b instanceof Lisp||!optimizeTypes[e.op]?e:optimizeTypes[e.op](e,t,r)}setOptimizeType([">","<",">=","<=","==","===","!=","!==","&&","||","&","|","+","-","/","*","**","%","$+","$-","!","~","group"],e=>ops.get(e.op)(e.a,e.b)),setOptimizeType(["string"],(e,t)=>t[e.b]),setOptimizeType(["literal"],(e,t,r)=>r[e.b].b.length?e:r[e.b].a),setOptimizeType(["createArray"],e=>e.b.find(e=>e instanceof Lisp)?e:ops.get(e.op)(e.a,e.b)),setOptimizeType(["prop"],e=>"number"==typeof e.b&&e.b%1==0?e.a[e.b]:e);export default class Sandbox{constructor(e={},t=new Map,r={audit:!1}){let n=new Prop({global:new SandboxGlobal(e)},"global",!1,!0);this.context={sandbox:this,globals:e,prototypeWhitelist:t,options:r,globalScope:new Scope(null,e,!0,n),globalProp:n,Function:()=>()=>{},eval:()=>{}},this.context.Function=sandboxFunction(this.context),this.context.eval=sandboxedEval(this.context.Function)}static get SAFE_GLOBALS(){return{Function:Function,eval:eval,console:console,isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math}}static get SAFE_PROTOTYPES(){let e=[SandboxGlobal,Function,Boolean,Object,Number,String,Date,RegExp,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise],t=new Map;return e.forEach(e=>{t.set(e,[])}),t}static audit(e,t=[]){let r=new Map;return new Sandbox(globalThis,r,{audit:!0}).executeTree(Sandbox.parse(e),t)}static parse(e,t=[],r=[]){let n,s=e,i="",o=!1,p=[],l=0;for(let e=0;e<s.length;e++){let a=s[e];if(o)if("$"===a&&"`"===n)a="$$";else if("u"===a){let t,r=/^[a-fA-F\d]{2,4}/.exec(s.substring(e+1));t=r?Array.from(r):Array.from(/^{[a-fA-F\d]+}/.exec(s.substring(e+1))||[""]),a=JSON.parse(`"\\u${t[0]}"`),s=s.substring(0,e-1)+a+s.substring(e+(1+t[0].length)),e-=1}else"`"!=a&&(a=JSON.parse(`"\\${a}"`));else"$"===a&&"`"===n&&"{"!==s[e+1]&&(a="$$");if("`"===n&&"$"===a&&"{"===s[e+1]){let n=restOfExp(s.substring(e+2),[/^}/]);p.push(this.parse(n,t,r).tree[0]),l+=n.length+3,i+=`\${${p.length-1}}`,e+=n.length+2}else if(n||"'"!==a&&'"'!==a&&"`"!==a||o)if(n!==a||o)n&&(o||"\\"!==a)&&(l+=o?1+a.length:a.length,i+=a);else{let o;"`"===n?(r.push({op:"literal",a:i,b:p}),s=s.substring(0,e-l-1)+`\`${r.length-1}\``+s.substring(e+1),o=(r.length-1).toString().length):(t.push(i),s=s.substring(0,e-i.length-1)+`"${t.length-1}"`+s.substring(e+1),o=(t.length-1).toString().length),n=null,e-=i.length-o,i=""}else p=[],l=0,n=a;o=n&&!o&&"\\"===a}return{tree:s.replace(/ instanceof /g," #io# ").replace(/(?:(^|\s))(return)(?=[\s;])/g,"#return#").replace(/(?:(^|\s))(var|let|const)(?=[\s])/g,e=>`#${e}#`).replace(/(?:(^|\s))typeof /g,"#to#").replace(/\s/g,"").split(";").filter(e=>e.length).map(e=>lispify(e)).map(e=>optimize(e,t,r)),strings:t,literals:r}}executeTree(e,t=[]){const r=e.tree,n=Object.assign(Object.assign({},this.context),{strings:e.strings,literals:e.literals});let s,i=this.context.globalScope;for(;s=t.shift();)"object"==typeof s&&(i=s instanceof Scope?s:new Scope(i,s));let o=Object.assign({},n);n.options.audit&&(o.auditReport={globalsAccess:new Set,prototypeAccess:{}});let p=!1,l=-1,a=r.map(e=>p?null:(l++,e instanceof Lisp&&"return"===e.op&&(p=!0),exec(e,i,o)))[l];return a=a instanceof Prop?a.context[a.prop]:a,{auditReport:o.auditReport,result:a}}compile(e){const t=Sandbox.parse(e);return(...e)=>this.executeTree(t,e).result}}